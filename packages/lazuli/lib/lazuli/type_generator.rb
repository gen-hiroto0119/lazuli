require "fileutils"
require "date"

require_relative "struct"
require_relative "types"
require_relative "resource"

module Lazuli
  class TypeGenerator
    TYPE_MAP = {
      String => "string",
      Integer => "number",
      Float => "number",
      Numeric => "number",
      TrueClass => "boolean",
      FalseClass => "boolean",
      Time => "string",
      Date => "string",
      DateTime => "string"
    }.freeze

    def self.generate(app_root:, out_path:)
      new(app_root: app_root, out_path: out_path).generate
    end

    def initialize(app_root:, out_path:)
      @app_root = File.expand_path(app_root)
      @out_path = File.expand_path(out_path)
    end

    def generate
      load_app_structs
      load_app_resources
      declarations = build_declarations
      FileUtils.mkdir_p(File.dirname(@out_path))
      File.write(@out_path, declarations)
    end

    private

    def load_app_structs
      $LOAD_PATH.unshift(@app_root) unless $LOAD_PATH.include?(@app_root)
      files = Dir[File.join(@app_root, "app", "structs", "**", "*.rb")].sort
      remaining = files.dup

      loop do
        loaded_in_pass = 0
        remaining.dup.each do |file|
          begin
            require file
            remaining.delete(file)
            loaded_in_pass += 1
          rescue NameError
            next
          end
        end
        break if remaining.empty?
        if loaded_in_pass.zero?
          raise "Unable to load structs due to unresolved constants: #{remaining.join(', ')}"
        end
      end
    end

    def build_declarations
      structs = ObjectSpace.each_object(Class).select { |c| c < Lazuli::Struct }
      resources = ObjectSpace.each_object(Class).select { |c| defined?(Lazuli::Resource) && c < Lazuli::Resource }
      @interface_names = build_interface_names(structs)

      seen = {}
      lines = ["// Generated by lazuli types", "// DO NOT EDIT MANUALLY", ""]

      structs.sort_by(&:name).each do |struct|
        key = struct.name
        next if seen[key]
        seen[key] = true

        lines << "export interface #{interface_name_for(struct)} {"
        struct.schema.each do |name, type|
          ts_type = map_type(type)
          lines << "  #{name}: #{ts_type};"
        end
        lines << "}"
        lines << ""
      end

      rpc_lines = build_rpc_declarations(resources)
      lines.concat(rpc_lines) unless rpc_lines.empty?

      lines.join("\n")
    end

    def load_app_resources
      files = Dir[File.join(@app_root, "app", "resources", "**", "*.rb")].sort
      files.each do |file|
        begin
          require file
        rescue StandardError
          # Best-effort: resources may reference unresolved constants; structs should still generate.
          next
        end
      end
    end

    def build_rpc_declarations(resources)
      defs = []
      resources.sort_by(&:name).each do |resource|
        next unless resource.respond_to?(:rpc_definitions)
        resource.rpc_definitions.each do |name, opts|
          ret = map_type(opts[:returns])
          defs << ["#{resource.name}##{name}", ret]
        end
      end

      return [] if defs.empty?

      lines = ["// RPC response types (from Resource.rpc)", "export interface RpcResponses {"]
      defs.sort_by(&:first).each do |key, ret|
        lines << "  \"#{key}\": #{ret};"
      end
      lines << "}"
      lines << ""
      lines
    end

    def build_interface_names(structs)
      by_basename = structs.group_by { |s| s.name.split('::').last }
      by_basename.each_with_object({}) do |(basename, klasses), hash|
        if klasses.length == 1
          hash[klasses.first.name] = basename
        else
          klasses.each do |k|
            hash[k.name] = k.name.gsub('::', '_')
          end
        end
      end
    end

    def interface_name_for(klass)
      @interface_names&.fetch(klass.name, klass.name.split('::').last) || klass.name.split('::').last
    end

    def map_type(type)
      return "any" if type.nil?
      return "null" if type == NilClass

      if defined?(Lazuli::Types)
        if type.is_a?(Lazuli::Types::Nilable)
          return "#{map_type(type.type)} | null"
        end

        if type.is_a?(Lazuli::Types::ArrayOf)
          return "#{map_type(type.type)}[]"
        end

        if type.is_a?(Lazuli::Types::Union)
          mapped = type.types.map { |t| map_type(t) }.compact.uniq
          return "any" if mapped.empty?
          return mapped.first if mapped.size == 1
          return mapped.join(" | ")
        end
      end

      # Back-compat: Array means array-of, optionally nullable array if NilClass included.
      if type.is_a?(Array)
        mapped = type.map { |t| map_type(t) }.compact.uniq
        return "any" if mapped.empty?

        null_part = mapped.delete("null") ? " | null" : ""
        return "#{mapped.first}[]#{null_part}" if mapped.size == 1
        return "(#{mapped.join(' | ')})[]#{null_part}"
      end

      TYPE_MAP.each do |ruby_type, ts_type|
        return ts_type if type <= ruby_type rescue false
      end

      return "any[]" if type == Array

      if defined?(Lazuli::Struct) && type.respond_to?(:<) && type < Lazuli::Struct
        return interface_name_for(type)
      end

      "any"
    end
  end
end
